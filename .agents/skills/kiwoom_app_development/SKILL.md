---
name: Kiwoom App Development Architecture & Guidelines
description: Instructions and guidelines for cleanly scaling the Kiwoom REST API application with Auto-trading, Telegram, and AI features based on an Event-Driven architecture.
---

# Kiwoom App Development Architecture & Guidelines

이 스킬 문서는 키움 API 기반 앱을 안정적으로 확장(자동매매, 텔레그램, AI 도입)하기 위해 AI 에이전트와 개발자가 지켜야 할 아키텍처 원칙과 개발 가이드라인을 정의합니다. 앞서 제안된 이벤트 기반(Event-Driven) 및 모듈 분리(Service) 구조를 성공적으로 적용하기 위한 지시사항입니다.

## 1. 지향하는 아키텍처 (Service & Event-Driven)
초기 형태에서는 `electron/main.ts`에 모든 로직이 집중되어 있었습니다. 이 상태에서 로직을 계속 추가하면 결합도가 높아져 유지보수가 불가능해집니다. 향후 개발 시에는 다음과 같은 원칙을 준수해야 합니다.

* **모듈 분리(Services)**: 각 비즈니스 로직은 `electron/services/` 디렉터리에 독립된 클래스/모듈로 작성합니다.
  * `KiwoomService`: 키움 API REST 호출, WebSocket 기반 실시간 시세 수집 담당
  * `AutoTradeService`: 매수/매도 타이밍 타당성 검토 및 스케줄링(주문 시그널 발송) 담당
  * `TelegramService`: 텔레그램 알림 발송 및 봇 상호작용
  * `AiService`: 외부 LLM 연동, 데이터 및 뉴스 취합을 통한 종목 리포트 생성
* **이벤트 버스(Event Bus) 통신**: 서비스 간 직접적인 호출(예: `KiwoomService` 안에서 `TelegramService.sendMessage()`를 직접 호출하는 행위)을 엄격히 금지합니다.
  * Node.js 내장 `EventEmitter` 를 기반으로 한 전용 EventBus 객체를 통해 소통합니다.
  * 예: 키움 서비스가 "체결됨(TRADE_EXECUTED)" 이벤트를 emit하면, 텔레그램 서비스가 구동 중일 때만 그 이벤트를 받아(listen) 메시지를 발송하게 만듭니다.
* **로컬 데이터베이스**: 검색 이력, 과거 차트 분석 이력, 트레이딩 로그 관리를 위해 로컬 SQLite (`better-sqlite3` 추천)를 적극 활용합니다.

## 2. 기능 확장 시 코딩 가이드라인

### 2.1 새로운 서비스(Feature)를 추가할 때
1. **역할 정의**: 해당 서비스가 정확히 '무엇'을 담당하는지 단일 책임 원칙에 따라 명확히 한정짓습니다.
2. **독립성 유지**: 다른 모듈의 내부 상태(private state)를 직접 읽거나 변경해서는 안 됩니다.
3. **Event 입출력 명세화**: 이 서비스가 발생시킬 수 있는 이벤트(`Emit`), 그리고 응답해야 하는 이벤트(`On`)의 목록을 코드 상단에 주석이나 인터페이스로 명시합니다.

### 2.2 텔레그램 연동 개발 가이드
* `telegraf` 등 라이브러리 사용 시, 봇 토큰은 절대 소스코드 내에 하드코딩하지 말고 `electron-store` 혹은 환경 변수 설정 화면을 통해 입력/관리 받도록 설계하세요.
* 텔레그램 연동(네트워크 통신) 로직이 실패하더라도 주 트레이딩 프로세스가 중단되지 않도록 예외(Exception) 처리를 엄격히 하세요.

### 2.3 AI 분석 기능 연동 가이드
* 시스템 프롬프트(지시문)와 주입되는 데이터(시세, 이슈 텍스트)를 분명히 분리하여 유지보수성을 높입니다.
* OpenAI, Claude 등 외부 공급자의 API 스펙이 변경될 가능성을 염두에 두고, `AiService` 내에 공통된 인터페이스 계층(Wrapper)을 만드세요.
* LLM API 비용을 최소화하기 위해 동일한 정보에 대한 분석 요청은 SQLite 혹은 로컬 캐싱 처리합니다.

## 3. UI/UX 업데이트 원칙
백엔드(Electron Main)가 분리되더라도 프론트엔드(React + Zustand)는 독립적인 구조를 유지해야 합니다.
* **단방향 통신 집중**: 프론트엔드에서 일어나는 모든 명령은 `window.electronAPI` 인터페이스 핸들러를 통해서만 백엔드에 전달합니다. UI에서 백엔드의 모듈을 직접 참조할 수 없습니다.
* **설정 UI 분리**: 기능이 거대해짐에 따라 AI나 자동매매 세팅 기능은 기존 화면에 욱여넣지 않고 새로운 탭(Tab)이나 설정(Settings) 다이얼로그로 독립시켜 여백과 사용성을 유지하세요.

## 4. 키움 REST API 연동 시 필수 고려사항 (제약 및 특징)
자동매매 및 각종 부가기능 연동 시 키움증권 OpenAPI의 특징을 반드시 고려해야 합니다.

* **API 호출 제한 (Rate Limit & Throttling)**: REST API 호출에 엄격한 속도 제한(TPS)이 적용됩니다. 순간적인 과부하(초당 과도한 요청) 발생 시 API 접근이 차단될 수 있으므로, `KiwoomService` 에는 반드시 **API 요청 큐(Queue) 및 스로틀링(Throttling)** 메커니즘을 적용하여 연속된 요청 간에 일정한 딜레이를 강제해야 합니다.
* **토큰 만료 완벽 처리 (8005 Error)**: Oauth 2.0 기반으로 작동하므로 토큰에 유효기간이 존재합니다. 프로그램 중단 없이 작동하는 자동매매 봇의 특성을 위해, **API 요청 시점에 토큰 만료 여부를 점검**하고 8005 에러 발생 시 스스로 토큰을 재발행한 뒤 실패했던 요청을 다시 이어가는 **자동 재시도(Retry) 로직**이 서비스 계층 최하단에 포함되어야 합니다.
* **WebSocket 구독 임계치 제한**: 실시간 시세를 수신하기 위한 WebSocket 연결에서 한 번에 수신할 수 있는 최대 종목(Symbol) 등록 개수에 제한이 있습니다. `AutoTradeService`와 연계 시 전체 시장 종목을 구독하는 것은 불가능하므로, 자동매매(조건검색) 등 **실제로 장중 감시가 필요한 종목만 필터링하여 동적으로 구독/구독해제를 관리**해야 합니다.
* **정규장 시간 제어 (Time 필터)**: 국내 주식 정규 시간(09:00 ~ 15:30) 외에는 정상적인 시세/체결 이벤트가 발생하지 않으므로, 스케줄링 프로세스에는 반드시 타임필터 방식이 들어가 불필요한 야간 API 호출을 방지해야 합니다.
* **동시 다발적 대량주문 제어**: 조건검색 결과로 수십 개 종목이 검색되었을 때 동시 매수를 시도하면 API 호출 한도 초과 및 증거금 부족 오류가 발생하기 쉽습니다. 주문 로직 처리 시 분할이나 동시 주문개수 통제 로직이 있어야 합니다.

## 5. AI 에이전트 필수 행동 수칙 (개발 프로세스)
이 프로젝트에서 새로운 기능을 개발하거나 코드를 수정하는 모든 AI 에이전트(혹은 협력 개발자)는 코딩을 시작하기 전 **반드시 아래의 절차를 준수**해야 합니다.

1. **계획 문서 확인**:
   * 개발 전 무조건 프로젝트 루트의 `PLAN.md`를 읽고 현재 진행 중인 단계(Phase)와 기존 아키텍처 제약사항을 확인합니다.
2. **사전 리서치 및 API 규격 확인**:
   * 기능 구현에 API 스펙이 필요한 경우, 섣불리 코드를 작성하지 않습니다.
   * `키움 REST API 문서.pdf` 또는 `키움 REST API 문서.xlsx` 등 문서를 검색하여 **엔드포인트(URL), 요청 헤더/바디, 정확한 응답 구조(Response JSON)**를 파악합니다.
3. **설계 공유 및 승인**:
   * 리서치 결과를 바탕으로 어떻게 코드를 모듈화(`electron/services/XxxService.ts`)할 것인지, 어떤 이벤트 버스 채널을 사용할 것인지 설계안을 먼저 작성합니다.
   * 사용자(User)에게 설계안을 제시하고 **승인(Confirm)을 받은 후**에만 실제 파일 쓰기(Coding)에 돌입합니다.
4. **점진적 구현 및 검증**:
   * 코드를 한 번에 수백 줄 작성하지 않고, 모듈별 단위로 구현한 후 서버 실행 또는 테스트를 통해 정상 작동(특히 API 인증, 호출 제한 등)을 확인하며 다음 단계로 넘어갑니다.
